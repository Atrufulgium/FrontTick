using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections.ObjectModel;

namespace Atrufulgium.FrontTick.Compiler.Datapack {
    /// <summary>
    /// <para>
    /// Represents the full codebase of a Minecraft datapack.
    /// </para>
    /// <para>
    /// This is NOT mutable. Please prepare all relavant data beforehand.
    /// </para>
    /// </summary>
    public class FullDatapack {
        // Keep them sorted alphabetically by path to keep the string output
        // consistent. Maybe it even helps with the filesystem output.
        private readonly SortedSet<IDatapackFile> files = new(DatapackFileComparer.Comparer);
        public ReadOnlyCollection<IDatapackFile> Files => new(files.ToList());

        public FullDatapack(params IEnumerable<IDatapackFile>[] files) {
            // Only add datapacks that are intended to be valid -- exactly the
            // ones with a valid name.
            foreach (var filelist in files)
                foreach (var file in filelist)
                    if (NameManager.IsValidDatapackName(file.Subpath))
                        this.files.Add(file);
                    else
                        throw new ArgumentException($"Found file with invalid datapack file name: {file.Subpath}");
        }

        /// <summary>
        /// Write this datapack's code to the specified folder.
        /// </summary>
        /// <param name="rootPath">
        /// The path to a datapack's directory, inside a minecraft world's
        /// datapack directory.
        /// </param>
        public void WriteToFilesystem(string rootPath) {
            char slash = Path.DirectorySeparatorChar;
            // TODO: Temp safeguard while I'm writing stuff still.
            if (!(rootPath.Contains(".minecraft") && rootPath.Contains("saves") && rootPath.Contains("datapacks")))
                throw new ArgumentException("The given path does not point to a minecraft world.");
            if (Directory.Exists(rootPath))
                Directory.Delete(rootPath, true);
            Directory.CreateDirectory(rootPath);
            using (var mcmeta = File.CreateText($"{rootPath}{slash}pack.mcmeta")) {
                mcmeta.Write(@"{
  ""pack"": {
    ""pack_format"": 9,
    ""description"": ""A datapack compiled by FrontTick.""
  }
}");
            }

            foreach (var file in files)
                file.WriteToFilesystem(rootPath);
        }

        /// <summary>
        /// Write this datapack's code to a large string of the form:
        /// <code>
        /// # (File namespace:filename1.mcfunction)
        /// scoreboard player add blah blah blah
        /// 
        /// # (File namespace:filename2.mcfunction)
        /// say hi
        /// # More commands, more files, etc.
        /// </code>
        /// </summary>
        public override string ToString()
            => ToString(false, false);

        readonly string[] skipInternalSpecifiers = new[] { "--", "bool.", "int.", "float.", "uint.", "system." };
        /// <summary>
        /// <inheritdoc cref="ToString"/>
        /// </summary>
        /// <remarks>
        /// <para>
        /// This variant, if <paramref name="skipInternal"/> is true, passes
        /// over any autogenerated standalone function file -- the files that
        /// are generated to process existing files are still printed.
        /// </para>
        /// <para>
        /// Similarly, if <paramref name="skipMCMirror"/> is true, any file in
        /// the MCMirror namespace are skipped.
        /// </para>
        /// </remarks>
        // These are found via the `<namespace>-internal:function` name.
        public string ToString(bool skipInternal = false, bool skipMCMirror = false) {
            StringBuilder result = new();
            foreach (var f in files) {
                // .. i really need a better mechanism for this
                if (skipInternal) {
                    bool cont = false;
                    foreach (var ignore in skipInternalSpecifiers) {
                        if (f.Subpath.Contains("internal/" + ignore)) {
                            cont = true;
                            break;
                        }
                    }
                    if (cont)
                        continue;
                }
                if (skipInternal && f is FunctionTag tag)
                    if (tag.Subpath == "test.json"
                        || (tag.Namespace == "minecraft" && tag.Subpath == "load.json")
                        || (tag.Namespace == "minecraft" && tag.Subpath == "tick.json"))
                        continue;
                if (skipMCMirror && f.Subpath.Contains($"internal/mcmirror"))
                    continue;
                result.Append($"# (File ({(string)f.DatapackLocation}) {f.Namespace}:{f.Subpath})\n{f.GetFileContents()}\n\n");
            }
            return result.ToString();
        }

        /// <summary>
        /// Write this datapack's code to a large string of the form:
        /// <code>
        /// # (File namespace:filename1.mcfunction)
        /// scoreboard player add blah blah blah
        /// function namespace:filename1-lorem
        ///     # (File namespace:filename1-lorem.mcfunction)
        ///     say lorem
        ///     function namespace:filename1-lorem-ipsum
        ///         # (File namespace:filename1-lorem-ipsum.mcfunction)
        ///         say ipsum
        ///     say dolor sit amet
        /// # More commands in filename1.mcfunction
        /// 
        /// # (File namespace:filename2.mcfunction)
        /// say hi
        /// # More commands, more files, etc.
        /// </code>
        /// More specifically, it nests a function's code into the first
        /// occurance of it being called if that function's name starts with
        /// the calling functions name, instead of being printed at root.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is to be used purely for debugging purposes and not for
        /// checking whether tests work as expected. For that, use
        /// <see cref="ToString"/>.
        /// </para>
        /// <para>
        /// In particular, this returns <i>only</i> the function files in the
        /// pack, and not anything else.
        /// </para>
        /// </remarks>
        public string ToTreeString(bool skipInternal = true, bool skipMCFunction = true) {
            string result = "";
            processedFunctions = new();
            var functionFiles = files.OfType<MCFunctionFile>();
            functionsByName = functionFiles.ToDictionary(file => file.Path, file => file);

            // Pre-emptively mark all files to skip as "processed".
            foreach (var file in functionFiles) {
                if (skipInternal && file.Path.name.Contains("-internal"))
                    processedFunctions.Add(file.Path);
                if (skipMCFunction && file.Path.name.Contains("internal/mcmirror"))
                    processedFunctions.Add(file.Path);
            }

            foreach (var file in files) {
                if (file is MCFunctionFile functionFile) {
                    if (!processedFunctions.Contains(functionFile.Path))
                        result += $"\n{GetTreeFunctionAtDepth(functionFile, functionFile.Path, 0)}";
                }
            }
            return result.Trim();
        }

        HashSet<MCFunctionName> processedFunctions;
        Dictionary<MCFunctionName, MCFunctionFile> functionsByName;
        private string GetTreeFunctionAtDepth(MCFunctionFile file, MCFunctionName topName, int depth) {
            processedFunctions.Add(file.Path);
            var indent = new string(' ', 4 * depth);
            // Header structure copypasta'd from
            /// <see cref="MCFunctionFile.ToString"/>
            var result = $"\n{indent}# (File {file.Path}.mcfunction)";
            if (file.code.Count == 0)
                result += $"\n{indent}# (Empty)";
            foreach (var line in file.code) {
                // Check if this file calls another function
                string function = null;
                if (line.StartsWith("function"))
                    function = line[9..]; // "function " takes up 9 chars.
                else {
                    int index = line.IndexOf("run function");
                    if (index >= 0)
                        function = line[(index + 13)..]; // "run function " takes up 13 chars.
                }
                // If this file calls another function, embed it after printing this line.
                result += $"\n{indent}{line}";
                if (function != null) {
                    // Yes I'm violating my own constructor requirement of "don't instantiate!"
                    // oops
                    // At least this is the result of a roundtrip MCFunction -> string -> MCFunction,
                    // so it cannot go wrong.
                    MCFunctionName nested = new(function);
                    if (nested.name.StartsWith(topName.name)
                        && !processedFunctions.Contains(nested)
                        && functionsByName.TryGetValue(nested, out var nestedFile))
                        result += GetTreeFunctionAtDepth(nestedFile, topName, depth + 1);
                }
            }
            return result;
        }
    }
}
